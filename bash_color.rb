##
# Provides logic for creating/displaying strings
# containing multiple colors formatted for bash
# (c) 2019, vdtdev
# @author Wade H. <vdtdev@gmail.com>
# @license MIT
module BashColor
    DEF_COLOR_SYMBOL='%'
    extend self
    ##
    # Colorize string using provided color settings
    # @param [String] text Text to colorize
    # @param [Hash] symbols Hash with named colors, each consisting of a 
    #       `:fg` and `:bg` key
    # @param [Hash] options Additional options hash
    # @option options [String] :symbol_character (`'%'`) Character to use as
    #       prefix for color change code. Default color's code is character
    #       repeated twice. Other codes are `(symbol)name`
    # @return [String] Copy of `text` with color codes injected
    def colorize(text, symbols, options={})
        sym_chr = options.fetch(:symbol_character, DEF_COLOR_SYMBOL)
        symbol_regexs = make_symbol_regexs(symbols, sym_chr)
        locations = find_color_symbols(text, symbol_regexs)
        raw = process_text(text, locations)
        str = ''
        # p raw
        # binding.pry
        raw.each do |r|
            if r.is_a?(Symbol)
                str.concat(color_code(symbols[r]))
            else
                str.concat(r)
            end
        end
        str
    end
    ## 
    # Wraps print, passing colorized text as input
    # @param [String] text Text to colorize and print
    # @param [Hash] symbols Hash with named colors, each consisting of a 
    #       `:fg` and `:bg` key
    # @param [Hash] options Additional options hash
    # @option options [String] :symbol_character (`'%'`) Character to use as
    #       prefix for color change code. Default color's code is character
    #       repeated twice. Other codes are `(symbol)name`
    # @see BashColor::colorize
    def cprint(text, colors={}, options={})
        printf colorize(text, colors, options)
    end
    private
    ##
    # Create color code string from preset hash
    # @param [Hash] preset Color preset hash
    # @return [String] Bash color code string
    def color_code(preset)
        "\033[#{preset[:bg]};#{preset[:fg]}m"
    end
    ##
    # Process text using code locations, generating an array
    # containing color code symbol names and inbetwen text
    # @param [String] text Source text
    # @param [Array] locations Array of code locations generated by
    #       `find_color_symbols`
    # @return [Array] Array containing text and color code symbols
    def process_text(text, locations)
        working = []
        return [text] if locations.length == 0
        
        if locations[0][:begin] > 0
            working << text[0..locations[0][:begin]-1]
        end

        locations.each_with_index do |l,i|
            is_last = locations.length - 1 - i == 0
            end_pos = -1
            if !is_last
                end_pos = locations[i+1][:begin] - 1
            end

            working << l[:symbol]
            working << text[l[:continue_pos]..end_pos]
        end

        working
    end
    ##
    # Makes Hash containing regular expressions for finding color codes
    # based off provided hash of color settings
    # @param [Hash] symbols Color settings hash
    # @param [String] symbol_character Character to use as symbol character
    # @return [Hash] Hash using input color keys with regex values
    def make_symbol_regexs(symbols, symbol_chr)
        custom = symbols.select{|k,v| k != :default}
        regexs = {}
        custom.each_pair do |k,v|
            regexs[k] = Regexp.compile(
                "(?<#{k.to_s}>(#{symbol_chr}#{k.to_s}))"
            )
        end
        regexs[:default] = Regexp.compile(
            "(?<default>(#{symbol_chr}#{symbol_chr}))"
        )
        regexs
    end

    ##
    # Finds locations of all color symbol codes within string,
    # returning an array of location info hashes
    # @param [String] text Source text
    # @param [Hash] symbols Color code regex hash (generated by `make_symbol_regexs`)
    # @return [Array] Array of location information hashes
    def find_color_symbols(text, symbols={})
        tracking = {}
        symbols.keys.each do |k|
            tracking[k] = {index: 0, done: false}
        end
        tracking_done = Proc.new {
            tracking.values.select{|t|!t[:done]}.length == 0
        }
        is_done = false

        locations = []

        until is_done do
            symbols.each_pair do |k,v|
                t = tracking[k]
                # print "Tracking #{k} (#{t})\n"
                unless t[:done]
                    m = v.match(text,t[:index])
                    if m.nil?
                        # print "No matches found\n"
                        tracking[k][:done] = true
                    else
                        tracking[k][:index] = m.end(0)
                        a=m.begin(0);b=m.end(0)
                        locations << {
                            symbol: k,
                            begin: a,
                            sym_end: b - 1,
                            continue_pos: b
                        }
                        # print "\tMatch found (#{a}..#{b}): #{text[a..b]}\n"
                    end
                end
            end
            is_done = tracking_done.call()
        end
        locations.sort{|a,b|a[:continue_pos]<=>b[:continue_pos]}
    end
end
